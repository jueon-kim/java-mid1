# Java Study

- 이 프로젝트는 Java 학습을 위한 개인 스터디 저장소 입니다.
- 김영한님의 java-mid1 강의를 보면서 정리한 내용압니다.
  https://inf.run/KFMK6

## 학습 목표
- Java의 기초 문법과 구조 이해
- 객체 및 클래스의 개념을 명확하게 익히기 
- 문자열, 날짜, 열겨형 등 다양한 Java API사용법 익히기 
- 예외처리 방식 및 내부 클래스 활용 학습 

## 학습 주제 
- java 기초 문법 이해 
- Object, 불면 객체
- String, 래퍼, Class, 열거형(Enum)
- 날짜와 시간, 중첩, 내부 클래스, 예외 처리 

## 🔒 불변 객체 (Immutable Object)

### 📌 불변 객체란?
불변 객체란 **한 번 생성된 이후 내부 상태(값)가 절대로 바뀌지 않는 객체를 말합니다.  
객체의 필드(상태)를 변경할 수 없기 때문에 사이드 이펙트(Side Effect)를 방지할 수 있습니다.

---

### ⚠️ 사이드 이펙트란?
여러 변수가 같은 객체를 공유(공유 참조)하고 있을 때 한 곳에서 값을 변경하면 다른 곳에도 영향을 주는 문제를 의미합니다.

불변 객체는 값을 변경할 수 없기 때문에 이러한 사이드 이펙트가 원천적으로 차단됩니다.

---

### ✅ 불변 객체의 특징

- 생성 후 객체의 내부 상태가 절대로 변경되지 않는다.
- 값을 변경하고 싶다면 새로운 객체를 만들어야 한다.
- 기존 객체를 참조하는 다른 변수에는 영향을 주지 않는다.
- 여러 쓰레드에서 동시에 접근해도 안전하다. (Thread-safe)

---

### 🔄 가변(Mutable) 객체 vs 불변(Immutable) 객체

| 구분         | 설명                                                                 |
|--------------|----------------------------------------------------------------------|
| 가변 객체     | 객체 생성 후 내부 상태가 변경될 수 있다.                             |
| 불변 객체     | 객체 생성 이후 내부 상태가 절대로 변하지 않는다.                     |

> 예시:
> - `Address` → 가변 클래스 (Mutable)
> - `ImmutableAddress` → 불변 클래스 (Immutable)
> - `String`, `Integer`, `LocalDate` 등은 자바에서 기본적으로 제공하는 불변 클래스입니다.

---

### 💡 왜 불변 객체를 사용하는가?

- ✅ 사이드 이펙트 방지: 여러 참조가 있을 때 값 변경으로 인한 예기치 않은 오류를 방지
- ✅ 멀티 쓰레드 안정성: 상태가 바뀌지 않기 때문에 동기화 없이 안전하게 사용할 수 있음
- ✅ 캐시 및 공유 객체 안정성: 여러 곳에서 공유해도 값이 바뀌지 않으므로 안전
- ✅ 값 타입(Entity 내부 등)의 안정성: JPA 등에서 값 타입 객체를 안정적으로 관리

---

### 🧠 기본형과 참조형의 차이

- 기본형 (Primitive Type)
    - 값을 공유하지 않는다.
    - 각 변수는 자신의 값을 독립적으로 가진다.
    - 예: `int`, `double`, `boolean`

- 참조형 (Reference Type)
    - 하나의 객체를 여러 변수가 참조할 수 있다.
    - 공유 참조가 가능하고, 변경 시 모든 참조에 영향을 줄 수 있다.
    - 예: `String`, `Address`, `Object`

> 따라서 참조형 데이터 타입에서는 불변 객체로 설계 하면 사이드 이펙트를 방지할 수 있습니다.

---

### 📘 정리

> 불변이라는 단순한 제약을 통해 사이드 이펙트와 같은 복잡한 문제를 효과적으로 막을 수 있습니다.  
> 클래스가 어디에, 어떻게 활용될지를 고려하며 불변 객체의 원리를 이해하고 설계해야 합니다.

## 🧵 String 클래스

### 내부 구조

- Java 8까지: `private final char[] value`
- Java 9부터: `private final byte[] value`

> 문자열은 너무 자주 사용되기 때문에 `+` 연산 등 자바 차원에서 다양한 편의 문법을 제공

---

### 🔍 문자열 리터럴 & 문자열 풀 (String Pool)

- `"hello"`와 같은 리터럴은 문자열 풀에 저장됨
- **동일한 문자열은 같은 인스턴스 참조** 사용 (메모리 효율 ↑)
- 문자열 풀은 힙 영역에 위치하며 해시 알고리즘을 통해 빠르게 검색됨

---

### 📌 String 클래스의 불변성

- 문자열 풀에서 공유되므로 **값 변경 시 다른 참조에도 영향**
- 불변으로 설계되어 있어 이러한 위험을 방지

---

## 🛠 StringBuilder

### 가변 문자열 클래스

- 내부에 `final`이 아닌 변경 가능한 `byte[]`를 가짐
- 문자열 변경 시 새로운 객체 생성이 필요 없음 → 성능/메모리 효율 ↑

### ✅ 사용 이유

| 구분               | 설명                                 |
|--------------------|--------------------------------------|
| `String`           | 불변. 변경 시마다 새 객체 생성        |
| `StringBuilder`    | 가변. 내부 문자열 직접 수정 가능     |

> 문자열 조작이 많은 경우 `StringBuilder` 사용이 성능상 유리

---

### StringBuilder 사용 예

- 반복문에서 문자열 누적
- 조건에 따라 동적 문자열 생성
- 긴 문자열 수정
- 복잡한 문자열 처리

---

### 🔁 StringBuilder vs StringBuffer

| 클래스         | 멀티 쓰레드 안전성 | 속도       |
|----------------|--------------------|------------|
| StringBuilder  | ❌ (비동기)          | 빠름       |
| StringBuffer   | ✅ (동기화 처리됨)   | 느림       |

> 단일 스레드 상황에서는 `StringBuilder`를, 멀티 스레드 상황에서는 `StringBuffer` 사용

---

## 🔗 메서드 체이닝 (Method Chaining)

- 메서드가 자신의 참조값을 반환하면 `.메서드()` 방식으로 **체이닝** 가능
- **코드를 간결하고 읽기 쉽게** 만들 수 있음

```java
String result = new StringBuilder()
                    .append("Hello")
                    .append(" World")
                    .toString();
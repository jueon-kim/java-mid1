# Java Study

- 이 프로젝트는 Java 학습을 위한 개인 스터디 저장소 입니다.
- 김영한님의 java-mid1 강의를 보면서 정리한 내용압니다.
  https://inf.run/KFMK6

## 학습 목표
- Java의 기초 문법과 구조 이해
- 객체 및 클래스의 개념을 명확하게 익히기 
- 문자열, 날짜, 열겨형 등 다양한 Java API사용법 익히기 
- 예외처리 방식 및 내부 클래스 활용 학습 

## 학습 주제 
- java 기초 문법 이해 
- Object, 불면 객체
- String, 래퍼, Class, 열거형(Enum)
- 날짜와 시간, 중첩, 내부 클래스, 예외 처리 

## 🔒 불변 객체 (Immutable Object)

### 📌 불변 객체란?
불변 객체란 **한 번 생성된 이후 내부 상태(값)가 절대로 바뀌지 않는 객체를 말합니다.  
객체의 필드(상태)를 변경할 수 없기 때문에 사이드 이펙트(Side Effect)를 방지할 수 있습니다.

---

### ⚠️ 사이드 이펙트란?
여러 변수가 같은 객체를 공유(공유 참조)하고 있을 때 한 곳에서 값을 변경하면 다른 곳에도 영향을 주는 문제를 의미합니다.

불변 객체는 값을 변경할 수 없기 때문에 이러한 사이드 이펙트가 원천적으로 차단됩니다.

---

### ✅ 불변 객체의 특징

- 생성 후 객체의 내부 상태가 절대로 변경되지 않는다.
- 값을 변경하고 싶다면 새로운 객체를 만들어야 한다.
- 기존 객체를 참조하는 다른 변수에는 영향을 주지 않는다.
- 여러 쓰레드에서 동시에 접근해도 안전하다. (Thread-safe)

---

### 🔄 가변(Mutable) 객체 vs 불변(Immutable) 객체

| 구분         | 설명                                                                 |
|--------------|----------------------------------------------------------------------|
| 가변 객체     | 객체 생성 후 내부 상태가 변경될 수 있다.                             |
| 불변 객체     | 객체 생성 이후 내부 상태가 절대로 변하지 않는다.                     |

> 예시:
> - `Address` → 가변 클래스 (Mutable)
> - `ImmutableAddress` → 불변 클래스 (Immutable)
> - `String`, `Integer`, `LocalDate` 등은 자바에서 기본적으로 제공하는 불변 클래스입니다.

---

### 💡 왜 불변 객체를 사용하는가?

- ✅ 사이드 이펙트 방지: 여러 참조가 있을 때 값 변경으로 인한 예기치 않은 오류를 방지
- ✅ 멀티 쓰레드 안정성: 상태가 바뀌지 않기 때문에 동기화 없이 안전하게 사용할 수 있음
- ✅ 캐시 및 공유 객체 안정성: 여러 곳에서 공유해도 값이 바뀌지 않으므로 안전
- ✅ 값 타입(Entity 내부 등)의 안정성: JPA 등에서 값 타입 객체를 안정적으로 관리

---

### 🧠 기본형과 참조형의 차이

- 기본형 (Primitive Type)
    - 값을 공유하지 않는다.
    - 각 변수는 자신의 값을 독립적으로 가진다.
    - 예: `int`, `double`, `boolean`

- 참조형 (Reference Type)
    - 하나의 객체를 여러 변수가 참조할 수 있다.
    - 공유 참조가 가능하고, 변경 시 모든 참조에 영향을 줄 수 있다.
    - 예: `String`, `Address`, `Object`

> 따라서 참조형 데이터 타입에서는 불변 객체로 설계 하면 사이드 이펙트를 방지할 수 있습니다.

---

### 📘 정리

> 불변이라는 단순한 제약을 통해 사이드 이펙트와 같은 복잡한 문제를 효과적으로 막을 수 있습니다.  
> 클래스가 어디에, 어떻게 활용될지를 고려하며 불변 객체의 원리를 이해하고 설계해야 합니다.

# 🧵 String 클래스

### 내부 구조

- Java 8까지: `private final char[] value`
- Java 9부터: `private final byte[] value`

> 문자열은 너무 자주 사용되기 때문에 `+` 연산 등 자바 차원에서 다양한 편의 문법을 제공

---

### 🔍 문자열 리터럴 & 문자열 풀 (String Pool)

- `"hello"`와 같은 리터럴은 문자열 풀에 저장됨
- **동일한 문자열은 같은 인스턴스 참조** 사용 (메모리 효율 ↑)
- 문자열 풀은 힙 영역에 위치하며 해시 알고리즘을 통해 빠르게 검색됨

---

### 📌 String 클래스의 불변성

- 문자열 풀에서 공유되므로 **값 변경 시 다른 참조에도 영향**
- 불변으로 설계되어 있어 이러한 위험을 방지

---

## 🛠 StringBuilder

### 가변 문자열 클래스

- 내부에 `final`이 아닌 변경 가능한 `byte[]`를 가짐
- 문자열 변경 시 새로운 객체 생성이 필요 없음 → 성능/메모리 효율 ↑

### ✅ 사용 이유

| 구분               | 설명                                 |
|--------------------|--------------------------------------|
| `String`           | 불변. 변경 시마다 새 객체 생성        |
| `StringBuilder`    | 가변. 내부 문자열 직접 수정 가능     |

> 문자열 조작이 많은 경우 `StringBuilder` 사용이 성능상 유리

---

### StringBuilder 사용 예

- 반복문에서 문자열 누적
- 조건에 따라 동적 문자열 생성
- 긴 문자열 수정
- 복잡한 문자열 처리

---

### 🔁 StringBuilder vs StringBuffer

| 클래스         | 멀티 쓰레드 안전성 | 속도       |
|----------------|--------------------|------------|
| StringBuilder  | ❌ (비동기)          | 빠름       |
| StringBuffer   | ✅ (동기화 처리됨)   | 느림       |

> 단일 스레드 상황에서는 `StringBuilder`를, 멀티 스레드 상황에서는 `StringBuffer` 사용

---

## 🔗 메서드 체이닝 (Method Chaining)

- 메서드가 자신의 참조값을 반환하면 `.메서드()` 방식으로 **체이닝** 가능
- **코드를 간결하고 읽기 쉽게** 만들 수 있음

```java
String result = new StringBuilder()
                    .append("Hello")
                    .append(" World")
                    .toString();
```

# 🧵 래퍼, class클래스 

기본형 연산이 래퍼 클래스보다 대략 5배 정도 빠른 것을 확인할 수 있다. 참고로 계산 결과는 시스템 마다 다르
다.
기본형은 메모리에서 단순히 그 크기만큼의 공간을 차지한다. 예를 들어 `int` 는 보통 4바이트의 메모리를 사용한
다.
래퍼 클래스의 인스턴스는 내부에 필드로 가지고 있는 기본형의 값 뿐만 아니라 자바에서 객체 자체를 다루는데
필요한 객체 메타데이터를 포함하므로 더 많은 메모리를 사용한다. 자바 버전과 시스템마다 다르지만 대략 8~16
바이트의 메모리를 추가로 사용한다.


**기본형, 래퍼 클래스 어떤 것을 사용?**
이 연산은 10억 번의 연산을 수행했을 때 0.3초와, 1.5초의 차이다.
기본형이든 래퍼 클래스든 이것을 1회로 환산하면 둘다 매우 빠르게 연산이 수행된다.
0.3초 나누기 10억, 1.5초 나누기 10억이다.
일반적인 애플리케이션을 만드는 관점에서 보면 이런 부분을 최적화해도 사막의 모래알 하나 정도의 차이가 날 뿐
이다.
CPU 연산을 아주 많이 수행하는 특수한 경우이거나, 수만~ 수십만 이상 연속해서 연산을 수행해야 하는 경우라
면 기본형을 사용해서 최적화를 고려하자.
그렇지 않은 일반적인 경우라면 코드를 유지보수하기 더 나은 것을 선택하면 된다.


**유지보수 vs 최적화**
- 유지보수 vs 최적화를 고려해야 하는 상황이라면 유지보수하기 좋은 코드를 먼저 고민해야 한다. 특히 최신 컴퓨터는 매우 빠르기 때문에 메모리 상에서 발생하는 연산을 몇 번 줄인다고해도 실질적인 도움이 되지 않는 경우가 많다.
- 코드 변경 없이 성능 최적화를 하면 가장 좋겠지만, 성능 최적화는 대부분 단순함 보다는 복잡함을 요구하고, 더 많은 코드들을 추가로 만들어야 한다. 최적화를 위해 유지보수 해야 하는 코드가 더 늘어나는 것이다. 그런데 진짜
문제는 최적화를 한다고 했지만 전체 애플리케이션의 성능 관점에서 보면 불필요한 최적화를 할 가능성이 있다.
- 특히 웹 애플리케이션의 경우 메모리 안에서 발생하는 연산 하나보다 네트워크 호출 한 번이 많게는 수십만배 더 오래 걸린다. 자바 메모리 내부에서 발생하는 연산을 수천번에서 한 번으로 줄이는 것 보다, 네트워크 호출 한 번 을 더 줄이는 것이 더 효과적인 경우가 많다. 

- 권장하는 방법은 개발 이후에 성능 테스트를 해보고 정말 문제가 되는 부분을 찾아서 최적화 하는 것이다.

## Class 클래스 

- 자바에서 `Class` 클래스는 클래스의 정보(메타데이터)를 다루는데 사용된다. `Class` 클래스를 통해 개발자는 실행
중인 자바 애플리케이션 내에서 필요한 클래스의 속성과 메서드에 대한 정보를 조회하고 조작할 수 있다.

- 타입 정보 얻기: 클래스의 이름, 슈퍼클래스, 인터페이스, 접근 제한자 등과 같은 정보를 조회할 수 있다.

- 리플렉션: 클래스에 정의된 메서드, 필드, 생성자 등을 조회하고, 이들을 통해 객체 인스턴스를 생성하거나 메서드
를 호출하는 등의 작업을 할 수 있다.

- 동적 로딩과 생성: `Class.forName()` 메서드를 사용하여 클래스를 동적으로 로드하고, `newInstance()`
메서드를 통해 새로운 인스턴스를 생성할 수 있다.

- -애노테이션 처리**: 클래스에 적용된 애노테이션(annotation)을 조회하고 처리하는 기능을 제공한다.


`Class` 클래스는 다음과 같이 3가지 방법으로 조회할 수 있다.
```java
Class clazz = String.class; // 1.클래스에서 조회
Class clazz = new String().getClass();// 2.인스턴스에서 조회
Class clazz = Class.forName("java.lang.String"); // 3.문자열로 조회
```

## System 클래스 
- System.in, System.out, System.err은 각각 표준 입력, 표준 출력, 표전 오류 스트림을 나타낸다 
- **시간 측정**: `System.currentTimeMillis()` 와 `System.nanoTime()` 은 현재 시간을 밀리초 또는 나노초
  단위로 제공한다.
 
- **환경 변수**: `System.getenv()` 메서드를 사용하여 OS에서 설정한 환경 변수의 값을 얻을 수 있다.
  
- **시스템 속성**: `System.getProperties()` 를 사용해 현재 시스템 속성을 얻거나
  `System.getProperty(String key)`
  로 특정 속성을 얻을 수 있다. 시스템 속성은 자바에서 사용하는 설정
  값이다.
  
- **시스템 종료**: `System.exit(int status)` 메서드는 프로그램을 종료하고, OS에 프로그램 종료의 상태 코
  드를 전달한다. 상태 코드
  `0` : 정상 종료
  상태 코드
  `0` 이 아님: 오류나 예외적인 종료

- **배열 고속 복사**: `System.arraycopy` 는 시스템 레벨에서 최적화된 메모리 복사 연산을 사용한다. 직접 반복문
  을 사용해서 배열을 복사할 때 보다 수 배 이상 빠른 성능을 제공한다.


## Math, Random클래스 
비곤 연산
지수 및 로그 
반올림 정밀도
삼각함수
기타 

### seed 

